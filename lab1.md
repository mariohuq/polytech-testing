\setcounter{section}{-1}
\newpage\refstepcounter{section}
# Введение {-}

В разработке ПО, помимо основной задачи --- реализовать заявленную в спецификации функциональность, --- существует не менее важная  задача --- обеспечить качество разработанного решения.

_Тестирование программного обеспечения_ --- проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов.

На практике ни один метод тестирования не может выявить _все_ ошибки
в программе.
Это связано с тем, что ресурсы проекта (деньги, время, персонал), в том числе и на тестирование, ограничены.
Но все-таки, правильно проведенное тестирование позволяет обнаружить
большинство ошибок, что позволит их оперативно исправить, и тем самым повысить качество программного обеспечения.

В данной лабораторной работе используется _ручное тестирование_ --- процесс проверки ПО, выполняемый специалистами без использования каких-либо специальных автоматизированных средств.

Ручное тестирование применяется не вместо компьютерного тестирования, а вместе с ним,
что позволяет выявить ошибки в программе на более ранних стадиях.

# Постановка задачи

Требуется: провести инспекцию кода, выступая в роли разработчика программы.

Для выполнения данной задачи необходимо:

- изучить методы ручного тестирования;
- провести инспекцию кода, проанализировать ее результаты;
- исправить программу в соответствии с рекомендациями специалиста по тестированию.

# Описание методов инспекции кода

Существуют три основных метода ручного тестирования:

- инспекция кода;<!-- (code inspection) -->
- сквозной просмотр;<!-- (walkthrough) -->
- тестирование удобства использования.<!-- (usability testing) -->

Эти методы могут применяться
на любой стадии разработки ПО,
причем как к отдельным готовым модулям или блокам, так и к приложению в целом.

Инспекция и сквозной просмотр включают в себя чтение или визуальную проверку исходного кода программы группой лиц. Оба метода предполагают выполнение определенной
подготовительной работы. Завершающим этапом является обмен мнениями между участниками проверки на специальном заседании. Цель такого заседания — нахождение ошибок,
но не их устранение (т.е. тестирование, а не отладка).[@mayers]

## Инспекция кода

_Инспекция кода_ --- это набор процедур и методик обнаружения ошибок путем анализа
(чтения) кода группой специалистов[@mayers].

### Группа инспектирования кода

Обычно в состав группы входят четыре человека, один из которых играет роль _координатора_. Координатор должен быть квалифицированным программистом, но не автором
тестируемой программы, детальное знание которой от него не требуется. Вторым участником группы является _программист_, а остальными — _проектировщик программы_ (если
это не сам программист) и _специалист по тестированию_[@mayers].

В рамках выполнения лабораторной работы в инспекции кода участвовало всего три
человека: программист, специалист по тестированию и координатор.

### Человеческий фактор

Если программист воспринимает инспектирование своей программы как деятельность,
направленную против него лично, и занимает оборонительную позицию, то процесс инспектирования не будет эффективным. Программист должен оставить самолюбие в стороне и
рассматривать инспекцию только в позитивном и конструктивном ключе, не забывая о
том, что целью инспекции является нахождение ошибок и, следовательно, улучшение качества программы[@mayers].

## Сквозной просмотр

Тестирование программы методом сквозного просмотра также как и в инспекции кода
включает в себя проверку программного кода группой лиц.

При сквозном просмотре код проверяется группой разработчиков (оптимально --- 3-4 человека), лишь один из которых является автором программы. Таким
образом, большую часть программы тестирует не ее создатель, а другие члены команды
разработчиков, что согласуется со вторым принципом, согласно которому тестирование
программистом собственной программы редко бывает эффективным.

Преимуществом сквозных просмотров, снижающим стоимость отладки (исправления ошибок), является возможность точной _локализации ошибки_. Кроме того, в процессе сквозного просмотра обычно удается выявить целую группу ошибок,
которые впоследствии можно устранить все вместе. При тестировании программы на компьютере обычно проявляются лишь признаки ошибок (например, программа не может
корректно завершиться или выводит бессмысленные результаты), а сами они обнаруживаются и устраняются по отдельности.[@mayers]

## Проверка за столом

Метод ручного тестирования «проверка за столом» может рассматриваться как инспекция или сквозной просмотр кода, выполняемые _одним человеком_, который вычитывает код программы, проверяет его, руководствуясь контрольным списком ошибок, и
(или) прогоняет через логику программы тестовые данные.

Для большинства людей проверка за столом является относительно непродуктивной.
Это объясняется прежде всего тем, что такая проверка представляет собой полностью
неупорядоченный процесс. Вторая, более важная причина заключается в том, что проверка за столом вступает в противоречие со _вторым принципом тестирования_, согласно
которому тестирование программистом собственных программ обычно оказывается неэффективным. Следовательно, оптимальный вариант состоит в том, чтобы такую проверку
выполнял человек, не являющийся автором программы (например, два программиста могут обмениваться программами для взаимной проверки, а не проверять собственные программы), но даже в этом случае такая проверка _менее эффективна_, чем сквозные
просмотры или инспекции. В основном именно по этой причине лучше, чтобы сквозные
просмотры или инспекции осуществлялись в группе[@mayers].

## Рецензирование

_Рецензирование_ — это процедура анонимной оценки общих характеристик качества,
обслуживаемости, расширяемости, удобства использования и ясности программного обеспечения. _Цель_ данного метода — предоставить программисту возможность получить
стороннюю оценку результатов своего труда.

Общее руководство процессом осуществляет _администратор_, выбираемый из числа
программистов. В свою очередь, администратор отбирает в группу рецензентов от 6 до 20
участников (6 — это необходимый минимум, обеспечивающий анонимность оценок). Предполагается, что все участники специализируются в одной области. Каждый из участников предоставляет для рецензирования
две своих программы, одну из которых он считает наилучшей, а вторую — наихудшей по
качеству.

Когда будут собраны все программы, их распределяют случайным образом между
участниками. Каждому участнику дают для рецензирования четыре программы. Две из
них относятся к категории «наилучших», а две — к категории «наихудших» программ, но
рецензенту не сообщают, какой именно является каждая из них. Любой участник тратит
на просмотр одной программы 30 минут и заполняет ее оценочную анкету. После просмотра всех четырех программ рецензент оценивает их относительное качество.

Рецензента также просят предоставить свои замечания к программе и дать рекомендации по ее улучшению.

После просмотра всех программ каждому участнику передают анкеты с оценками двух
его программ. Кроме того, участники получают _статистическую сводку_, отражающую
общие и детализированные данные о рейтинге их собственных программ среди всего набора, а также анализ того, насколько оценки, данные участником чужим программам,
близки к оценкам тех же программ со стороны других рецензентов.[@mayers]

# Технология инспекции кода

## Состав группы

Заседание происходило в следущем составе:

- секретарь Калугин Евгений, исполняющий роль координатора;
- специалист по тестированию Чалков Кирилл;
- программист Кондраев Дмитрий, он же проектировщик программы.

## Исходный код программы

<!-- На вход подается список ребер с неотрицательными весами неориентированного графа, вершины которого обозначены числами от 1 до $n$.
Вес маршрута --- это максимум из весов ребер графа, составляющих маршрут.

Программа выводит вес самого легкого маршрута от вершины 1 до вершины $n$ (то есть имеющего минимальный вес). Если такого маршрута нет, выводит число `Integer.MAX_VALUE`. -->

### `Task.java` {-}

```java
import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public final class Task {
    private Task() {
        // Should not be instantiated
    }

    private static void solve(final FastScanner in, final PrintWriter out) {
        int nVertices = in.nextInt();
        int mEdges = in.nextInt();
        Graph g = new Graph(nVertices, mEdges);
        for (int i = 0; i < mEdges; i++) {
            g.addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());
        }
        g.sortEdges();
        out.println(kruskalMstMinMaxPath(g));
    }

    private static int kruskalMstMinMaxPath(Graph g) {
        DisjointSetUnion f = new DisjointSetUnion(g.vertices());
        for (Edge edge : g.edges()) {
            if (f.get(edge.from) == f.get(edge.to)) {
                continue;
            }
            f.union(edge.to, edge.from);
            if (f.get(0) == f.get(g.vertices() - 1)) {
                return edge.weight;
            }
        }
        return Integer.MAX_VALUE;
    }

    private static class DisjointSetUnion {
        final int[] parent;
        final int[] rank;

        public DisjointSetUnion(int size) {
            parent = IntStream.range(0, size).toArray();
            rank = new int[size];
        }

        public int get(int x) {
            if (x != parent[x]) {
                parent[x] = get(parent[x]);
            }
            return parent[x];
        }

        public void union(int x, int y) {
            x = get(x);
            y = get(y);
            if (rank[x] < rank[y]) {
                parent[x] = y;
            } else {
                parent[y] = x;
            }
            if (rank[x] == rank[y]) {
                rank[y]++;
            }
        }
    }

    private static class Graph {
        private final Edge[] edges;
        private int edgesCount;
        private final int verticesCount;

        public Graph(int verticesCount, int edgesCount) {
            this(verticesCount, new Edge[edgesCount]);
        }

        private Graph(int verticesCount, Edge[] edges) {
            this.edges = edges;
            this.verticesCount = verticesCount;
        }

        public void addEdge(int from, int to, int weight) {
            edges[edgesCount++] = new Edge(from, to, weight);
        }

        public Edge[] edges() {
            return edges;
        }

        public void sortEdges() {
            Arrays.sort(edges, Comparator.comparing(e -> e.weight));
        }

        public int vertices() {
            return verticesCount;
        }

        public int edgesCount() {
            return edgesCount;
        }
    }

    private static class Edge {
        public final int from;
        public final int to;
        public final int weight;

        public Edge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(final InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return tokenizer.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }
    }

    public static void main(final String[] arg) {
        final FastScanner in = new FastScanner(System.in);
        try (PrintWriter out = new PrintWriter(System.out)) {
            solve(in, out);
        }
    }
}
```

## Список вопросов и ответов на них

Ниже представлен список вопросов, которые специалист по тестированию Чалков задавал программисту Кондраеву. После каждого вопроса приведен ответ. После некоторых ответов слудуют замечания специалиста по тестированию. 

1. Программа реализует алгоритм Краскала?

    _Ответ:_ Да.

2. На каком языке написана программа?

    _Ответ:_ Java.

3. Какие типы переменных используются?

    _Ответ:_ int, Graph, DisjointSetUnion, Edge.

4. Все ли константные переменные объявлены при их инициализации?

    _Ответ:_ Все переменные инициализируются при объявлении или в конструкторах.

5. Где-то используется индексация массивов?

    _Ответ:_ Да, в методах get, union.

6. Проверяется ли аргумент индексации что он целочисленный?

    _Ответ:_ Да, по типу.

7. Корректно ли названы все методы и переменные?

    _Ответ:_ Да, кроме полей Edge.from, to.

    _Замечание:_ Следует более осмысленно назвать переменные.

8. Возможно ли деление на 0?

    _Ответ:_ Нет.

9. Как выполняются проверки сравнения?

    _Ответ:_ Сравниваются значения, полученные при вызове функций.

10. Есть ли операторы сравнения с целыми константами?

    _Ответ:_ Нет.

11. Используются ли переменные double, float?

    _Ответ:_ Нет.

12. Может ли какая-нибудь переменная типа int переполниться?

    _Ответ:_ В методе union есть операция `++`. Теоретически да, но на практике невозможно, т. к. возможный размер массива в языке ограничен. 

13. Соблюдены ли правила наследования объектов?

    _Ответ:_ Наследование не используется.

14. Все ли переменные объявлены?

    _Ответ:_ Да.

15. Правильно ли инициализированы массивы и строки?

    _Ответ:_ Строк в программе нет, а массивы --- да.

16. Удаляются ли неиспользуемые переменные из памяти?

    _Ответ:_ Используется автоматический сборщик мусора.

17. Присутствуют ли в программе потенциально бесконечные циклы?

    _Ответ:_ Нет.

18. Может ли значение индекса выйти за размер массива?

    _Ответ:_ Нет.

19. Проверяются ли входные данные на принадлежность к домену?

    _Ответ:_ Не проверяются.

    _Замечание:_ Стоит проверять данные на принадлежность к домену.

21. Используются ли логические выражения?

    _Ответ:_ Да, в методе FastScanner.next.

    _Замечание_: Тут лучше писать сначала логическое выражение, или константу а потом переменную. Т.к. можно случайно поставить одно `=` вместо двух.

22. Используются ли файлы для ввода-вывода?

    _Ответ:_ Нет.

23. У всех ли классов есть конструктор?

    _Ответ:_ Да.

24. В цикле for корректно ли написана операция сравнения в цикле?

    _Ответ:_ Да

25. Переменная nEdges всегда больше 0?

    _Ответ:_ На это нет проверки.

    _Замечание_: Стоит добавить проверку.   

26. Совпадает ли число аргументов, передаваемых вызываемым модулям и число ожидаемых параметров?

    _Ответ:_ Да

27. Делаются ли в программе попытки поправить входные аргументы?

    _Ответ:_ В методе DisjointSetUnion.get переменной x присваивается новое значение. В конструкторе Graph --- нет.

28. Нет ли пропущенных функций?

    _Ответ:_ Нет. Все функции реализованы.

29. Выдаются ли предупреждения при компиляции?

    _Ответ:_ Нет.

30. Выдаются ли ошибки при компиляции?

    _Ответ:_ Тоже нет.

31. Выполняются ли вычисления с присваиванием несовпадающих типов?

    _Ответ:_ Нет.

32. Есть ли комментарии в программе?

    _Ответ:_ Один есть.

    _Замечание_: Стоит добавить разъяснительные комментарии.


33. Оформлен ли код в соответствии с некоторым регламентом (стандартом оформления)?

    _Ответ:_ Да.


# Код программы с внесенными изменениями

Результатом метода инспекции кода является список правок, которые необходимо внести в программу:

1. Добавить проверку входных данных на принадлежность к домену.
2. Переписать метод FastScanner.next, изменив порядок условий в логическом выражении.
3. Добавить проверку, что nEdges > 0.
4. Добавить комментарии в программу.
5. Выбрать более осмысленные имена для переменных Edge.from и to.

### `Task.java` {-}

```java
import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public final class Task {
    private Task() {
        // Should not be instantiated
    }

    private static void solve(final FastScanner in, final PrintWriter out) {
        int nVertices = in.nextInt();
        if (nVertices <= 0) {
            out.println("Число вершин не может быть отрицательным или 0.");
            return;
        }
        int mEdges = in.nextInt();
        if (mEdges <= 0) {
            out.println("Число ребер не может быть отрицательным или 0.");
            return;
        }
        Graph g = new Graph(nVertices, mEdges);
        for (int i = 0; i < mEdges; i++) {
            g.addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());
        }
        g.sortEdges();
        out.println(kruskalMstMinMaxPath(g));
    }

    // Алгоритм Краскала поиска минимального остова графа
    // Ребра упорядочены по возрастанию веса.
    // Ребро, на котором останавливается процесс объединения компонент
    // связности --- наибольшего веса в минимальном по весу пути.
    private static int kruskalMstMinMaxPath(Graph g) {
        DisjointSetUnion f = new DisjointSetUnion(g.vertices());
        for (Edge edge : g.edges()) {
            if (f.get(edge.fromVertex) == f.get(edge.toVertex)) {
                continue;
            }
            f.union(edge.toVertex, edge.fromVertex);
            if (f.get(0) == f.get(g.vertices() - 1)) {
                return edge.weight;
            }
        }
        return Integer.MAX_VALUE;
    }

    // Реализация структуры данных "система непересекающихся множеств".
    // Используется ранговая эвристика на основе глубины деревьев.
    private static class DisjointSetUnion {
        final int[] parent;
        final int[] rank;

        public DisjointSetUnion(int size) {
            parent = IntStream.range(0, size).toArray();
            rank = new int[size];
        }

        public int get(int x) {
            if (x != parent[x]) {
                parent[x] = get(parent[x]);
            }
            return parent[x];
        }

        public void union(int x, int y) {
            x = get(x);
            y = get(y);
            if (rank[x] < rank[y]) {
                parent[x] = y;
            } else {
                parent[y] = x;
            }
            if (rank[x] == rank[y]) {
                rank[y]++;
            }
        }
    }

    private static class Graph {
        private final Edge[] edges;
        private int edgesCount = 0;
        private final int verticesCount;

        public Graph(int verticesCount, int edgesCount) {
            this(verticesCount, new Edge[edgesCount]);
        }

        private Graph(int verticesCount, Edge[] edges) {
            this.edges = edges;
            this.verticesCount = verticesCount;
        }

        public void addEdge(int from, int to, int weight) {
            if (from < 0 || from >= verticesCount) {
                throw new IllegalArgumentException("Не является номером вершины: " + from);
            }
            if (to < 0 || to >= verticesCount) {
                throw new IllegalArgumentException("Не является номером вершины: " + from);
            }
            edges[edgesCount++] = new Edge(from, to, weight);
        }

        public Edge[] edges() {
            return edges;
        }

        public void sortEdges() {
            Arrays.sort(edges, Comparator.comparing(e -> e.weight));
        }

        public int vertices() {
            return verticesCount;
        }

        public int edgesCount() {
            return edgesCount;
        }
    }

    private static class Edge {
        public final int fromVertex;
        public final int toVertex;
        public final int weight;

        public Edge(int fromVertex, int toVertex, int weight) {
            this.fromVertex = fromVertex;
            this.toVertex = toVertex;
            this.weight = weight;
        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(final InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        String next() {
            while (null == tokenizer || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return tokenizer.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }
    }

    public static void main(final String[] arg) {
        final FastScanner in = new FastScanner(System.in);
        try (PrintWriter out = new PrintWriter(System.out)) {
            solve(in, out);
        }
    }
}
```

# Обобщение работы группы

В ходе работы группы в программе были найдены некоторые ошибки: не было проверок корректности входных данных; некоторые переменные имели неудачные названия; сложные для понимания фрагменты программы не комментировались.

Сделан вывод, что код писался по регламенту, а значит удобен для чтения.

Получен опыт проведения ручного тестирования методом инспекции кода, разбора кода
в группе, ответов на вопросы о коде.

\newpage\refstepcounter{section}
# Заключение {-}
    
В ходе выполнения данной лабораторной работы был изучен метод ручного тестирования — инспекция кода. Было проведено инспекционное собрание, на котором участвовали секретарь, программист и специалист по тестированию.

По итогу собрания был составлен протокол заседания, далее программистом был проведен анализ составленного протокола и внесены необходимые изменения в код программы.

В результате выполненной работы, можно сделать вывод, что методы ручного тестирования, в частности инспекция кода, являются эффективными для выявления ошибок в
логике программы, а также для выявления несоответствий требованиям.

\newpage\refstepcounter{section}
# Список использованных источников {-}

::: {#refs}
:::